<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <link rel="stylesheet" href="tutorial.css">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />

    <title>Tutorial</title>
  </head>
  <body>
    <h1>How to Create a Quiz App</h1>
    <p>This app uses ReactJS for the client and Node and Express for the server. Both are written in Typescript.</p>
    <h3>Prerequisites</h3>
    <p>
      This tutorial requires Node.js to be installed, git (optional) and also VS
      Code (optional) as code editor.
    </p>
    <h3>1. Setup project structure</h3>
    <p>
      Create a <code>quiz-app1</code> folder, in this folder run the <code>git init</code> command
      (optional), then create two sub-folders: <code>server</code> and <code>client</code> under the
      <code>quiz-app1</code> folder. Open the <code>quiz-app1</code> folder in VS Code.
    </p>
    <h3>2. Setup server</h3>
    <p>
      Inside the <code>server</code> sub-folder run <code>npm init -y</code> command. To add typescript we will now run the <code>npm install --save-dev
      typescript</code> command. Next, we need to add <code>tsconfig.json</code> file with the
      settings for tsc compiler. Add the  <code>tsconfig.json</code> file under the <code>server</code>
      sub-folder and copy the following into it.
      <div class="code-snippet-header">tsconfig.js</div>
      <div class="code-snippet">
      <span
        ><pre
          >{ 
              "compilerOptions": { 
                  "target": "es2016", 
                  "module": "commonjs",
                  "sourceMap": true, 
                  "outDir": "./dist", 
                  "esModuleInterop": true,
                  "forceConsistentCasingInFileNames": true, 
                  "strict": true,
                  "skipLibCheck": true 
                }, 
                "include": ["src/**/*"] 
            }
      </pre></span
      ></div>
      Please note the <code>outDir</code> setting that instructs the tsc compiler
      where to place its' output .js files.
      <br />Now we can install <code>express</code> library (for our web service) and <code>nedb</code>
      library (for our database). We will also install <code>nodemon</code> to allow
      automatic compiling after source code edits. Run the following two
      commands: <code><br />npm install express nedb <br />npm install --save-dev
      @types/express @types/nedb nodemon
      <br /></code>
      <p>
      We are almost done setting up the server project. We just need to setup
      how to start our server in our developement environment. To do so, add the
      following lines in the <code>package.json</code> file inside the "scripts" block
      </p>
      <div class="code-snippet-header">package.js</div>
      <div class="code-snippet">
          <span
        ><pre>
            "dev": "node ./node_modules/nodemon/bin/nodemon.js -e ts --exec \"npm run compile\"", 
            "compile": "npx tsc && node ./dist/main.js"</pre
        ></span
      >
      </div>
      <br />
      Now, every time our code changes, two main processes will occur:
      compilation and restart of our server from it's start point in <code>./dist/main.js</code> which is a compilation result of <code>main.ts</code>
    </p>
    <h3>3. Server implementation</h3>
    <p>
      The server must have an entry point. And so, our server's enty point is in the <code>main.ts</code> in the <code>src</code>
      sub-folder. If you have downloaded or copied the code, for this tutorial you can now start the server and make sure that it does indeed start up. We
      will use the "dev" script that we have already specified to run the server
      in the developement environment. Run the "npm run dev" command in the
      "server" sub-folder. You should see the "quiz server open for requests on
      port 80" message.
    </p>
    <h3>Server and Routers</h3>
    <p>
      We will extract the code that manages the server into <code>quiz_server.ts</code> and
      the code that manages quiz-related PUT, POST, etc. requests into the
      <code>quiz_router.ts</code>. 
      <br/>
        The <code>quiz_server.ts</code> defines a class to represent our server. Inside it, 
        we load the router for any  <code>/quiz</code> quiz-related requests.
       <div class="code-snippet-header">quiz_server.ts</div>
      <div class="code-snippet">
      <span>

        <pre><code>
            private initRoute() {
                this.app.use(this.quizUrl, require("./quiz_router"));
            }</code></pre
        >
      </span>
    </div>
      
      The <code>quiz_router.ts</code> creates an express router that will
      define and implement an endpoint for each RESTful request that our server can handle. For example,

      <div class="code-snippet-header">quiz_router.ts</div>
      <div class="code-snippet">
      <span>

        <pre><code>
            quizRouter.get("/:id", async (req, res, next) => {
                try {
                    const id = req.params.id;
                    const quizWorker: QuizWorker = new QuizWorker();
                    const quiz: IQuiz = await quizWorker.getQuizById(id);
                    if (!quiz) {
                    throw new QuizNotFound(id);
                    }
                    res.json(quiz);
                    next();
                } catch (err) {
                    next(err);
                }
                });</code></pre
        >
      </span>
    </div>
      Here, the GET request creates a <code>QuizWorker</code> object that in it's turn passes the request to
      the database by calling <code>await quizWorker.getQuizById(id)</code> that returns a quiz. In case no such quiz is found in the database, 
      this code throws a custom <code>QuizNotFound</code> exception. Here, we make sure that this and any other exception will be handled by the 
      error handler that is part of the moddlewear by calling <code>next(err)</code> in the <code>catch</code> block. 
      <br/>
      <i>Quick aside  error handling mechanism- //tbd</i>
      <br/>
      The error handler that is defined in the end of <code>quiz-router</code> module accepts either an <code>Error</code> or our 
      custom exception <code>BaseException</code> and sends an error status message, and detailed info as a responce:
      <div class="code-snippet-header">quiz_router.ts</div>
      <div class="code-snippet">
      <span>
        <pre><code>
          quizRouter.use(
            (err: BaseError | Error, req: Request, res: Response, next: NextFunction) => {
                console.log(
                `ERROR:: ${req.method} ${req.baseUrl}${req.url} - ${err.message}`
                );

                let error: BaseError;
                if (!(err instanceof BaseError)) {
                error = new BaseError(500, err.message, err.stack);
                } else {
                error = err;
                }
                res
                .status(error.status)
                .send({ message: error.message, details: error.details });
            }
            );
</code></pre
        >
      </span>
    </div>
      In case there is a quiz with such an <i>id</i> and it was retrieved successfully by our worker, a call to <code>next();</code> 
      ensures our middleware will be called for logging the end of this GET method.
      <br/>
      Speaking of the middleware other than error handling, it currenly does only two things: logs at the begining of any 
      request to the router and logs in the end. The code below:
      <div class="code-snippet-header">quiz_router.ts</div>
      <div class="code-snippet">
      <span>
        <pre><code>
          quizRouter.use((req, res, next) => {
            //log date and time, method, and url for each request
            console.log(
                `>> ${new Date(Date.now()).toLocaleString()} ${req.method} ${req.baseUrl}${
                req.url
                } `
            );
            next();
            });</code></pre
        >
      </span>
    </div>
    will execute each time one of the endpoints <code>quizRouter</code> is invoked and will output something resembling
    <div class="output-snippet-header">quiz_router.ts</div>
      <div class="output-snippet">
      <span>
        <pre><code>
            &gt;&gt; 2022-05-04, 2:22:23 p.m. GET /quiz/</code></pre
        >
      </span>
    </div>
    In addition, just as each method finishes executing, the code below will run:
    <div class="code-snippet-header">quiz_router.ts</div>
      <div class="code-snippet">
      <span>
        <pre><code>
            quizRouter.use((req, res, next) => {
                //log end of each request
                console.log(`&lt;&lt;END ${req.method} ${req.baseUrl}${req.url} `);
                next();
                });</code></pre
        >
      </span>
    </div>
    This will result in an output of 
    <div class="output-snippet-header">quiz_router.ts</div>
      <div class="output-snippet">
      <span>
        <pre><code>
            &lt;&lt; END GET /quiz/</code></pre
        >
      </span>
    </div>
    </p>
    <h3>QuizWorker</h3>
    <p>
        This worker class implements the CRUD methods to retrieve, create, update and delete quizzes.
        <br/>
        The <code>Nedb</code> database is a file located in the <code>quiz-app1/server/dist</code>, and it will be created if it doesn't yet exist.
        <div class="code-snippet-header">quiz_worker.ts</div>
      <div class="code-snippet">
      <span>

        <pre><code>
            constructor() {
                this._db = new Nedb({
                filename: path.join(__dirname, "quiz.db"),
                autoload: true,
                });
            }</code></pre
        >
      </span>
    </div>

    Adding a quiz is implemented, not surprisingly, in <code>addQuiz</code> method: 
     <div class="code-snippet-header">quiz_worker.ts</div>
      <div class="code-snippet">
      <span>

        <pre><code>
        public addQuiz(quiz: IQuiz): Promise&lt;IQuiz&gt; {
            console.log("IN QuizWorker.addQuiz()", quiz);

            return new Promise&lt;IQuiz&gt((resolveHandler, rejectHandler) => {
            this._db.insert&lt;IQuiz&gt(quiz, (err: Error | null, newQuiz: IQuiz) => {
                if (err) {
                console.log("ERROR in QuizWorker.addQuiz(): ", err);
                rejectHandler(err);
                } else {
                console.log("SUCCESS in QuizWorker.addQuiz(): ", newQuiz);
                resolveHandler(newQuiz);
                }
            });
            });
        }
        </code></pre
        >
      </span>
    </div>
    <code>addQuiz</code> returns a <code>Promise&lt;IQuiz&gt</code>. The promise expects, and accepts, a callback function as a parameter. 
    According to the documentation, "This callback is passed two arguments: a resolve callback used to resolve the promise with a value or the result of another promise, and a reject callback used to reject the promise with a provided reason or error."
    We use the <code>Nedb.insert</code> function and in its callback either resolve the promise or reject it in case of an error.
    </p>
  </body>
</html>
